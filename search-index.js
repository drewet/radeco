var searchIndex = {};
searchIndex['radeco'] = {"items":[[0,"","radeco","",null,null],[0,"analysis","","",null,null],[0,"valueset","radeco::analysis","",null,null],[3,"KnownBits","radeco::analysis::valueset","Value set described by bits set/cleared in the u64",null,null],[12,"zerobits","","Bits that are cleared",0,null],[12,"onebits","","Bits that are set",0,null],[3,"UIntMultiple","","",null,null],[12,"modulus","","",1,null],[12,"residue","","",1,null],[3,"UIntRange","","",null,null],[12,"min","","",2,null],[12,"max","","",2,null],[3,"SIntRange","","",null,null],[12,"min","","",3,null],[12,"max","","",3,null],[11,"contains","","",0,{"inputs":[{"name":"knownbits"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"as_umultiple","","",0,{"inputs":[{"name":"knownbits"}],"output":{"name":"uintmultiple"}}],[11,"as_urange","","",0,{"inputs":[{"name":"knownbits"}],"output":{"name":"uintrange"}}],[11,"as_srange","","",0,{"inputs":[{"name":"knownbits"}],"output":{"name":"sintrange"}}],[11,"contains","","",2,{"inputs":[{"name":"uintrange"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"contains","","",3,{"inputs":[{"name":"sintrange"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"contains","","",1,{"inputs":[{"name":"uintmultiple"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"scan_up","","",1,{"inputs":[{"name":"uintmultiple"},{"name":"u64"}],"output":{"name":"option"}}],[11,"scan_dn","","",1,{"inputs":[{"name":"uintmultiple"},{"name":"u64"}],"output":{"name":"option"}}],[11,"as_knownbits","","",1,{"inputs":[{"name":"uintmultiple"}],"output":{"name":"knownbits"}}],[11,"as_urange","","",1,{"inputs":[{"name":"uintmultiple"}],"output":{"name":"uintrange"}}],[11,"as_srange","","",1,{"inputs":[{"name":"uintmultiple"}],"output":{"name":"sintrange"}}],[8,"ValueSet","","A value set",null,null],[10,"contains","","Returns whether the value belngs",4,{"inputs":[{"name":"valueset"},{"name":"t"}],"output":{"name":"bool"}}],[8,"ScannableSet","","A value set over a totally ordered domain with methods to query the next greater or smaller value",null,null],[10,"scan_up","","Return Some(x) where x ≥ value and x ∈ self",5,{"inputs":[{"name":"scannableset"},{"name":"t"}],"output":{"name":"option"}}],[10,"scan_dn","","Return Some(x) where x ≤ value and x ∈ self",5,{"inputs":[{"name":"scannableset"},{"name":"t"}],"output":{"name":"option"}}],[11,"fmt","","",0,{"inputs":[{"name":"knownbits"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"knownbits"}],"output":{"name":"knownbits"}}],[11,"fmt","","",1,{"inputs":[{"name":"uintmultiple"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"uintmultiple"}],"output":{"name":"uintmultiple"}}],[11,"fmt","","",2,{"inputs":[{"name":"uintrange"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"uintrange"}],"output":{"name":"uintrange"}}],[11,"fmt","","",3,{"inputs":[{"name":"sintrange"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"sintrange"}],"output":{"name":"sintrange"}}],[6,"Output","","",null,null],[6,"Output","","",null,null],[11,"bitand","","",0,null],[6,"Output","","",null,null],[11,"bitand","","",0,null],[6,"Output","","",null,null],[6,"Output","","",null,null],[11,"bitand","","",1,null],[6,"Output","","",null,null],[11,"bitand","","",1,null],[6,"Output","","",null,null],[6,"Output","","",null,null],[11,"bitand","","",2,null],[6,"Output","","",null,null],[11,"bitand","","",2,null],[6,"Output","","",null,null],[6,"Output","","",null,null],[11,"bitand","","",3,null],[6,"Output","","",null,null],[11,"bitand","","",3,null],[6,"Output","","",null,null],[6,"Output","","",null,null],[11,"bitor","","",0,null],[6,"Output","","",null,null],[11,"bitor","","",0,null],[6,"Output","","",null,null],[6,"Output","","",null,null],[11,"bitor","","",1,null],[6,"Output","","",null,null],[11,"bitor","","",1,null],[6,"Output","","",null,null],[6,"Output","","",null,null],[11,"bitor","","",2,null],[6,"Output","","",null,null],[11,"bitor","","",2,null],[6,"Output","","",null,null],[6,"Output","","",null,null],[11,"bitor","","",3,null],[6,"Output","","",null,null],[11,"bitor","","",3,null],[0,"propagate","radeco::analysis","",null,null],[0,"data","radeco::analysis::propagate","",null,null],[8,"DataOperator","radeco::analysis::propagate::data","",null,null],[10,"join","","",6,null],[0,"frontend","radeco","",null,null],[0,"esil","radeco::frontend","Module to parse ESIL strings and convert them into the IR.",null,null],[3,"Operator","radeco::frontend::esil","",null,null],[3,"Value","","",null,null],[3,"Instruction","","",null,null],[12,"addr","","",7,null],[12,"opcode","","",7,null],[12,"dst","","",7,null],[12,"operand_1","","",7,null],[12,"operand_2","","",7,null],[3,"Parser","","",null,null],[4,"ParseError","","",null,null],[13,"InvalidOperator","","",8,null],[13,"InsufficientOperands","","",8,null],[4,"Arity","","",null,null],[13,"Zero","","",9,null],[13,"Unary","","",9,null],[13,"Binary","","",9,null],[13,"Ternary","","",9,null],[4,"Location","","",null,null],[13,"Memory","","",10,null],[13,"Register","","",10,null],[13,"Constant","","",10,null],[13,"Temporary","","",10,null],[13,"Unknown","","",10,null],[13,"Null","","",10,null],[4,"Opcode","","",null,null],[13,"OpAdd","","",11,null],[13,"OpSub","","",11,null],[13,"OpMul","","",11,null],[13,"OpDiv","","",11,null],[13,"OpMod","","",11,null],[13,"OpAnd","","",11,null],[13,"OpOr","","",11,null],[13,"OpXor","","",11,null],[13,"OpNot","","",11,null],[13,"OpEq","","",11,null],[13,"OpCmp","","",11,null],[13,"OpGt","","",11,null],[13,"OpLt","","",11,null],[13,"OpGteq","","",11,null],[13,"OpLteq","","",11,null],[13,"OpLsl","","",11,null],[13,"OpLsr","","",11,null],[13,"OpInc","","",11,null],[13,"OpDec","","",11,null],[13,"OpIf","","",11,null],[13,"OpBr","","",11,null],[13,"OpRef","","",11,null],[13,"OpNarrow","","",11,null],[13,"OpWiden","","",11,null],[13,"OpNop","","",11,null],[11,"fmt","","",8,{"inputs":[{"name":"parseerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",9,{"inputs":[{"name":"arity"},{"name":"arity"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"arity"},{"name":"arity"}],"output":{"name":"bool"}}],[11,"clone","","",9,{"inputs":[{"name":"arity"}],"output":{"name":"arity"}}],[11,"fmt","","",9,{"inputs":[{"name":"arity"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"location"},{"name":"location"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"location"},{"name":"location"}],"output":{"name":"bool"}}],[11,"clone","","",10,{"inputs":[{"name":"location"}],"output":{"name":"location"}}],[11,"fmt","","",10,{"inputs":[{"name":"location"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"operator"}],"output":{"name":"operator"}}],[11,"fmt","","",12,{"inputs":[{"name":"operator"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",12,{"inputs":[{"name":"operator"},{"name":"str"},{"name":"arity"}],"output":{"name":"operator"}}],[11,"nop","","",12,{"inputs":[{"name":"operator"}],"output":{"name":"operator"}}],[11,"eq","","",11,{"inputs":[{"name":"opcode"},{"name":"opcode"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"opcode"},{"name":"opcode"}],"output":{"name":"bool"}}],[11,"clone","","",11,{"inputs":[{"name":"opcode"}],"output":{"name":"opcode"}}],[11,"fmt","","",11,{"inputs":[{"name":"opcode"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",11,{"inputs":[{"name":"opcode"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"value"}],"output":{"name":"value"}}],[11,"fmt","","",13,{"inputs":[{"name":"value"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",13,{"inputs":[{"name":"value"},{"name":"string"},{"name":"u8"},{"name":"location"},{"name":"i64"},{"name":"u32"}],"output":{"name":"value"}}],[11,"null","","",13,{"inputs":[{"name":"value"}],"output":{"name":"value"}}],[11,"tmp","","",13,{"inputs":[{"name":"value"},{"name":"u64"},{"name":"u8"}],"output":{"name":"value"}}],[11,"constant","","",13,{"inputs":[{"name":"value"},{"name":"i64"}],"output":{"name":"value"}}],[11,"fmt","","",13,{"inputs":[{"name":"value"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"instruction"}],"output":{"name":"instruction"}}],[11,"fmt","","",7,{"inputs":[{"name":"instruction"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",7,{"inputs":[{"name":"instruction"},{"name":"opcode"},{"name":"value"},{"name":"value"},{"name":"value"},{"name":"option"}],"output":{"name":"instruction"}}],[11,"fmt","","",7,{"inputs":[{"name":"instruction"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",14,{"inputs":[{"name":"parser"}],"output":{"name":"parser"}}],[11,"parse","","",14,{"inputs":[{"name":"parser"},{"name":"str"},{"name":"option"}],"output":{"name":"result"}}],[11,"emit_insts","","",14,{"inputs":[{"name":"parser"}],"output":{"name":"vec"}}],[0,"cfg","radeco::frontend","This module is used to convert the instructions generated from esil into\na CFG.",null,null],[3,"BasicBlock","radeco::frontend::cfg","A `BasicBlock` is the basic unit in a CFG. Every `Instruction` must be a\npart of one and only one `BasicBlock`. Every instruction in the\n`BasicBlock` executes sequentially. This `BasicBlock` implementation\ndoes not store the instructions themselves but rather just stores the\nindices of the instructions that belong to a block as a `Range`.\nNote that rust ranges are half-open. This means that the last value is not\nincluded as a part of this `Range`, i.e. (a..b) => [a, b).",null,null],[12,"range","","",15,null],[12,"index","","",15,null],[12,"reachable","","",15,null],[12,"instructions","","",15,null],[12,"label","","",15,null],[3,"CFG","","",null,null],[12,"g","","",16,null],[12,"insts","","",16,null],[12,"start","","",16,null],[5,"make_graph","","",null,{"inputs":[{"name":"vec"}],"output":null}],[11,"new","","",16,{"inputs":[{"name":"cfg"}],"output":{"name":"cfg"}}],[11,"build","","",16,{"inputs":[{"name":"cfg"}],"output":null}],[11,"add_new_block","","",16,{"inputs":[{"name":"cfg"}],"output":{"name":"basicblock"}}],[11,"add_block","","",16,{"inputs":[{"name":"cfg"},{"name":"basicblock"}],"output":null}],[0,"dot","radeco::frontend","Module to parse and write dot files for graphs.",null,null],[5,"make_dot","radeco::frontend::dot","",null,{"inputs":[{"name":"cfg"}],"output":null}],[8,"Dot","","",null,null],[10,"to_dot","","",17,{"inputs":[{"name":"dot"}],"output":{"name":"string"}}],[11,"to_dot","radeco::frontend::cfg","",16,{"inputs":[{"name":"cfg"}],"output":{"name":"string"}}],[11,"to_dot","","",15,{"inputs":[{"name":"basicblock"}],"output":{"name":"string"}}],[11,"to_dot","radeco::frontend::esil","",7,{"inputs":[{"name":"instruction"}],"output":{"name":"string"}}],[0,"backend","radeco","",null,null],[3,"D","radeco::backend","",null,null],[0,"lang_c","","",null,null],[5,"serialize","radeco::backend::lang_c","Serializes SCFNodes for debugging purposes.\nTODO: Newlines and indentation, also cover all constructs",null,{"inputs":[{"name":"scfnode"}],"output":{"name":"string"}}],[0,"scf","radeco::backend","",null,null],[3,"MutRefDomain","radeco::backend::scf","Tells SCFNode to refer to children via &SCFNode",null,null],[3,"BoxDomain","","Tells SCFNode to refer to children via Box<SCFNode> (for testing only)",null,null],[4,"ForInitClause","","This enum distinguishes between\nfor(x=1;;) and\nfor(int x=1;;)",null,null],[13,"InitDeclaration","","",18,null],[13,"InitExpression","","",18,null],[4,"SCFNode","","Enum to represent *syntactic* flow structures in C.",null,null],[13,"Empty","","",19,null],[13,"Statement","","",19,null],[13,"Seq","","",19,null],[12,"body","radeco::backend::scf::SCFNode","",19,null],[12,"noreturn","","",19,null],[13,"Cond","radeco::backend::scf","",19,null],[12,"cond","radeco::backend::scf::SCFNode","",19,null],[12,"body","","",19,null],[12,"alt","","",19,null],[13,"Switch","radeco::backend::scf","",19,null],[12,"selector","radeco::backend::scf::SCFNode","",19,null],[12,"cases","","",19,null],[12,"default","","",19,null],[13,"While","radeco::backend::scf","",19,null],[12,"cond","radeco::backend::scf::SCFNode","",19,null],[12,"body","","",19,null],[13,"DoWhile","radeco::backend::scf","",19,null],[12,"cond","radeco::backend::scf::SCFNode","",19,null],[12,"body","","",19,null],[13,"For","radeco::backend::scf","",19,null],[12,"init","radeco::backend::scf::SCFNode","",19,null],[12,"cond","","",19,null],[12,"step","","",19,null],[12,"body","","",19,null],[8,"SCFDomain","radeco::backend::scf","A trait to pass to SCFNode to control the types for declarations,\nexpressions, statements, and most importantly to child SCFNodes.\nThe choice of the name 'Domain' was arbitrary.",null,null],[16,"Declaration","radeco::backend::scf::SCFDomain","",null,null],[16,"Expression","","",null,null],[16,"Statement","","",null,null],[16,"Node","","",null,null],[6,"Declaration","radeco::backend::scf","",null,null],[6,"Expression","","",null,null],[6,"Statement","","",null,null],[6,"Node","","",null,null],[6,"Declaration","","",null,null],[6,"Expression","","",null,null],[6,"Statement","","",null,null],[6,"Node","","",null,null],[11,"fmt","","",18,{"inputs":[{"name":"forinitclause"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",19,{"inputs":[{"name":"scfnode"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","radeco::backend","",20,{"inputs":[{"name":"d"},{"name":"formatter"}],"output":{"name":"result"}}],[6,"Declaration","","",null,null],[6,"Expression","","",null,null],[6,"Statement","","",null,null],[6,"Node","","",null,null],[0,"util","radeco","",null,null],[5,"blcic","radeco::util","",null,{"inputs":[{"name":"u64"}],"output":{"name":"u64"}}],[5,"tzmsk","","",null,{"inputs":[{"name":"u64"}],"output":{"name":"u64"}}],[5,"gcd_lcm","","",null,null],[5,"multiplicative_inverse","","",null,{"inputs":[{"name":"u64"},{"name":"u64"}],"output":{"name":"option"}}]],"paths":[[3,"KnownBits"],[3,"UIntMultiple"],[3,"UIntRange"],[3,"SIntRange"],[8,"ValueSet"],[8,"ScannableSet"],[8,"DataOperator"],[3,"Instruction"],[4,"ParseError"],[4,"Arity"],[4,"Location"],[4,"Opcode"],[3,"Operator"],[3,"Value"],[3,"Parser"],[3,"BasicBlock"],[3,"CFG"],[8,"Dot"],[4,"ForInitClause"],[4,"SCFNode"],[3,"D"]]};
searchIndex['petgraph'] = {"items":[[0,"","petgraph","**petgraph** is a graph data structure library.",null,null],[3,"MinScored","","**MinScored\\<K, T\\>** holds a score **K** and a scored object **T** in\na pair for use with a **BinaryHeap**.",null,null],[3,"Directed","","Marker type for a directed graph.",null,null],[3,"Undirected","","Marker type for an undirected graph.",null,null],[3,"Ptr","","A reference that is hashed and compared by its pointer value.",null,null],[4,"EdgeDirection","","Edge direction",null,null],[13,"Outgoing","","A **Outgoing** edge is an outward edge *from* the current node.",0,null],[13,"Incoming","","An **Incoming** edge is an inbound edge *to* the current node.",0,null],[11,"fmt","","",1,{"inputs":[{"name":"minscored"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"minscored"}],"output":{"name":"minscored"}}],[11,"eq","","",1,{"inputs":[{"name":"minscored"},{"name":"minscored"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"minscored"},{"name":"minscored"}],"output":{"name":"option"}}],[11,"cmp","","",1,{"inputs":[{"name":"minscored"},{"name":"minscored"}],"output":{"name":"ordering"}}],[0,"algo","","Graph algorithms.",null,null],[5,"is_isomorphic","petgraph::algo","Return **true** if the graphs **g0** and **g1** are isomorphic.",null,{"inputs":[{"name":"graph"},{"name":"graph"}],"output":{"name":"bool"}}],[5,"dijkstra","","Dijkstra's shortest path algorithm.",null,{"inputs":[{"name":"g"},{"name":"g"},{"name":"option"},{"name":"f"}],"output":{"name":"hashmap"}}],[5,"is_cyclic_undirected","","Return **true** if the input graph contains a cycle.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic","","**Deprecated: Renamed to *is_cyclic_undirected*.**",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic_directed","","Check if a directed graph contains cycles.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"toposort","","Perform a topological sort of a directed graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"scc","","Compute *Strongly connected components* using Kosaraju's algorithm.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"connected_components","","Return the number of connected components of the graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[5,"min_spanning_tree","","Return a *Minimum Spanning Tree* of a graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[0,"graphmap","petgraph","**GraphMap\\<N, E\\>** is an undirected graph where node values are mapping keys.",null,null],[3,"GraphMap","petgraph::graphmap","**GraphMap\\<N, E\\>** is an undirected graph, with generic node values **N** and edge weights **E**.",null,null],[3,"Nodes","","",null,null],[3,"Neighbors","","",null,null],[3,"Edges","","",null,null],[12,"from","","",2,null],[12,"edges","","",2,null],[12,"iter","","",2,null],[8,"NodeTrait","","A trait group for **GraphMap**'s node identifier.",null,null],[11,"clone","","",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"graphmap"}}],[11,"fmt","","",3,{"inputs":[{"name":"graphmap"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new **GraphMap**.",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"self"}}],[11,"with_capacity","","Create a new **GraphMap** with estimated capacity.",3,{"inputs":[{"name":"graphmap"},{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"node_count","","Return the number of nodes in the graph.",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"usize"}}],[11,"edge_count","","Return the number of edges in the graph.",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"usize"}}],[11,"clear","","Remove all nodes and edges",3,{"inputs":[{"name":"graphmap"}],"output":null}],[11,"add_node","","Add node **n** to the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"n"}}],[11,"remove_node","","Return **true** if node **n** was removed.",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"bool"}}],[11,"contains_node","","Return **true** if the node is contained in the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"bool"}}],[11,"add_edge","","Add an edge connecting **a** and **b** to the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"},{"name":"e"}],"output":{"name":"bool"}}],[11,"remove_edge","","Remove edge from **a** to **b** from the graph and return the edge weight.",3,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[11,"contains_edge","","Return **true** if the edge connecting **a** with **b** is contained in the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"bool"}}],[11,"nodes","","Return an iterator over the nodes of the graph.",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"nodes"}}],[11,"neighbors","","Return an iterator over the nodes that are connected with **from** by edges.",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"neighbors"}}],[11,"edges","","Return an iterator over the nodes that are connected with **from** by edges,\npaired with the edge weight.",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"edges"}}],[11,"edge_weight","","Return a reference to the edge weight connecting **a** with **b**, or\n**None** if the edge does not exist in the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[11,"edge_weight_mut","","Return a mutable reference to the edge weight connecting **a** with **b**, or\n**None** if the edge does not exist in the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[6,"Item","","",null,null],[11,"next","","",4,{"inputs":[{"name":"nodes"}],"output":{"name":"option"}}],[11,"size_hint","","",4,null],[11,"next_back","","",4,{"inputs":[{"name":"nodes"}],"output":{"name":"option"}}],[6,"Item","","",null,null],[11,"next","","",5,{"inputs":[{"name":"neighbors"}],"output":{"name":"option"}}],[11,"size_hint","","",5,null],[11,"next_back","","",5,{"inputs":[{"name":"neighbors"}],"output":{"name":"option"}}],[6,"Item","","",null,null],[11,"next","","",2,{"inputs":[{"name":"edges"}],"output":{"name":"option"}}],[6,"Output","","",null,null],[11,"index","","",3,null],[11,"index_mut","","",3,null],[0,"graph","petgraph","**Graph\\<N, E, Ty, Ix\\>** is a graph datastructure using an adjacency list representation.",null,null],[3,"NodeIndex","petgraph::graph","Node identifier.",null,null],[3,"EdgeIndex","","Edge identifier.",null,null],[3,"Node","","The graph's node type.",null,null],[12,"weight","","Associated node data.",6,null],[3,"Edge","","The graph's edge type.",null,null],[12,"weight","","Associated edge data.",7,null],[3,"Graph","","**Graph\\<N, E, Ty, Ix\\>** is a graph datastructure using an adjacency list representation.",null,null],[3,"WithoutEdges","","An iterator over either the nodes without edges to them or from them.",null,null],[3,"Neighbors","","Iterator over the neighbors of a node.",null,null],[3,"Edges","","Iterator over the edges of a node.",null,null],[6,"DefIndex","","The default integer type for node and edge indices in **Graph**.\n**u32** is the default to reduce the size of the graph's data and improve\nperformance in the common case.",null,null],[8,"IndexType","","Trait for the unsigned integer type used for node and edge indices.",null,null],[10,"new","","",8,{"inputs":[{"name":"indextype"},{"name":"usize"}],"output":{"name":"self"}}],[10,"index","","",8,{"inputs":[{"name":"indextype"}],"output":{"name":"usize"}}],[10,"max","","",8,{"inputs":[{"name":"indextype"}],"output":{"name":"self"}}],[10,"zero","","",8,{"inputs":[{"name":"indextype"}],"output":{"name":"self"}}],[10,"one","","",8,{"inputs":[{"name":"indextype"}],"output":{"name":"self"}}],[11,"hash","","",9,null],[11,"cmp","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"lt","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"le","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"gt","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"ge","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"eq","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"fmt","","",9,{"inputs":[{"name":"nodeindex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"nodeindex"}],"output":{"name":"nodeindex"}}],[11,"new","","",9,{"inputs":[{"name":"nodeindex"},{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",9,{"inputs":[{"name":"nodeindex"}],"output":{"name":"usize"}}],[11,"end","","",9,{"inputs":[{"name":"nodeindex"}],"output":{"name":"self"}}],[11,"hash","","",10,null],[11,"cmp","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"lt","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"le","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"gt","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"ge","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"eq","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"clone","","",10,{"inputs":[{"name":"edgeindex"}],"output":{"name":"edgeindex"}}],[11,"new","","",10,{"inputs":[{"name":"edgeindex"},{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",10,{"inputs":[{"name":"edgeindex"}],"output":{"name":"usize"}}],[11,"end","","An invalid **EdgeIndex** used to denote absence of an edge, for example\nto end an adjacency list.",10,{"inputs":[{"name":"edgeindex"}],"output":{"name":"self"}}],[11,"fmt","","",10,{"inputs":[{"name":"edgeindex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"node"}],"output":{"name":"node"}}],[11,"fmt","","",6,{"inputs":[{"name":"node"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next_edge","","Accessor for data structure internals: the first edge in the given direction.",6,{"inputs":[{"name":"node"},{"name":"edgedirection"}],"output":{"name":"edgeindex"}}],[11,"clone","","",7,{"inputs":[{"name":"edge"}],"output":{"name":"edge"}}],[11,"fmt","","",7,{"inputs":[{"name":"edge"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",7,{"inputs":[{"name":"edge"},{"name":"edgedirection"}],"output":{"name":"edgeindex"}}],[11,"source","","Return the source node index.",7,{"inputs":[{"name":"edge"}],"output":{"name":"nodeindex"}}],[11,"target","","Return the target node index.",7,{"inputs":[{"name":"edge"}],"output":{"name":"nodeindex"}}],[11,"clone","","",11,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[11,"fmt","","",11,{"inputs":[{"name":"graph"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new **Graph** with directed edges.",11,{"inputs":[{"name":"graph"}],"output":{"name":"self"}}],[11,"new_undirected","","Create a new **Graph** with undirected edges.",11,{"inputs":[{"name":"graph"}],"output":{"name":"self"}}],[11,"with_capacity","","Create a new **Graph** with estimated capacity.",11,{"inputs":[{"name":"graph"},{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"node_count","","Return the number of nodes (vertices) in the graph.",11,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[11,"edge_count","","Return the number of edges in the graph.",11,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[11,"clear","","Remove all nodes and edges",11,{"inputs":[{"name":"graph"}],"output":null}],[11,"is_directed","","Return whether the graph has directed edges or not.",11,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[11,"into_edge_type","","Cast the graph as either undirected or directed. No edge adjustments\nare done.",11,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[11,"add_node","","Add a node (also called vertex) with weight **w** to the graph.",11,{"inputs":[{"name":"graph"},{"name":"n"}],"output":{"name":"nodeindex"}}],[11,"node_weight","","Access node weight for node **a**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"node_weight_mut","","Access node weight for node **a**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"neighbors","","Return an iterator of all nodes with an edge starting from **a**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[11,"neighbors_directed","","Return an iterator of all neighbors that have an edge between them and **a**,\nin the specified direction.\nIf the graph is undirected, this is equivalent to *.neighbors(a)*.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"edgedirection"}],"output":{"name":"neighbors"}}],[11,"neighbors_undirected","","Return an iterator of all neighbors that have an edge between them and **a**,\nin either direction.\nIf the graph is undirected, this is equivalent to *.neighbors(a)*.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[11,"edges","","Return an iterator over the neighbors of node **a**, paired with their respective edge\nweights.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"edges"}}],[11,"edges_both","","Return an iterator over the edgs from **a** to its neighbors, then *to* **a** from its\nneighbors.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"edges"}}],[11,"add_edge","","Add an edge from **a** to **b** to the graph, with its edge weight.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"},{"name":"e"}],"output":{"name":"edgeindex"}}],[11,"update_edge","","Add or update an edge from **a** to **b**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"},{"name":"e"}],"output":{"name":"edgeindex"}}],[11,"edge_weight","","Access the edge weight for **e**.",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"edge_weight_mut","","Access the edge weight for **e** mutably.",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"remove_node","","Remove **a** from the graph if it exists, and return its weight.\nIf it doesn't exist in the graph, return **None**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"remove_edge","","Remove an edge and return its edge weight, or **None** if it didn't exist.",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"find_edge","","Lookup an edge from **a** to **b**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"find_edge_undirected","","Lookup an edge between **a** and **b**, in either direction.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"reverse","","Reverse the direction of all edges",11,{"inputs":[{"name":"graph"}],"output":null}],[11,"raw_nodes","","Access the internal node array",11,null],[11,"raw_edges","","Access the internal edge array",11,null],[11,"first_edge","","Accessor for data structure internals: the first edge in the given direction.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"edgedirection"}],"output":{"name":"option"}}],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"},{"name":"edgedirection"}],"output":{"name":"option"}}],[11,"without_edges","","Return an iterator over either the nodes without edges to them or from them.",11,{"inputs":[{"name":"graph"},{"name":"edgedirection"}],"output":{"name":"withoutedges"}}],[6,"Item","","",null,null],[11,"next","","",12,{"inputs":[{"name":"withoutedges"}],"output":{"name":"option"}}],[6,"Item","","",null,null],[11,"next","","",13,{"inputs":[{"name":"neighbors"}],"output":{"name":"option"}}],[6,"Item","","",null,null],[11,"next","","",14,{"inputs":[{"name":"edges"}],"output":{"name":"option"}}],[6,"Output","","",null,null],[11,"index","","",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"n"}}],[11,"index_mut","","",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"n"}}],[6,"Output","","",null,null],[11,"index","","",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"e"}}],[11,"index_mut","","",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"e"}}],[0,"visit","petgraph","Graph visitor algorithms.",null,null],[3,"AsUndirected","petgraph::visit","Wrapper type for walking the graph as if it is undirected",null,null],[3,"Reversed","","Wrapper type for walking edges the other way",null,null],[3,"Dfs","","A depth first search (DFS) of a graph.",null,null],[12,"stack","","The stack of nodes to visit",15,null],[12,"discovered","","The map of discovered nodes",15,null],[3,"DfsIter","","An iterator for a depth first traversal of a graph.",null,null],[3,"Bfs","","A breadth first search (BFS) of a graph.",null,null],[12,"stack","","The queue of nodes to visit",16,null],[12,"discovered","","The map of discovered nodes",16,null],[3,"BfsIter","","An iterator for a breadth first traversal of a graph.",null,null],[8,"Graphlike","","Base trait for graphs that defines the node identifier.",null,null],[16,"NodeId","petgraph::visit::Graphlike","",null,null],[8,"NeighborIter","petgraph::visit","A graph trait for accessing the neighbors iterator",null,null],[16,"Iter","petgraph::visit::NeighborIter","",null,null],[10,"neighbors","petgraph::visit","Return an iterator that visits all neighbors of the node **n**.",17,{"inputs":[{"name":"neighboriter"},{"name":"nodeid"}],"output":{"name":"iter"}}],[8,"VisitMap","","A mapping from node → is_visited.",null,null],[10,"visit","","Return **true** if the value is not already present.",18,{"inputs":[{"name":"visitmap"},{"name":"n"}],"output":{"name":"bool"}}],[10,"is_visited","","",18,{"inputs":[{"name":"visitmap"},{"name":"n"}],"output":{"name":"bool"}}],[8,"Visitable","","Trait for GraphMap that knows which datastructure is the best for its visitor map",null,null],[16,"Map","petgraph::visit::Visitable","",null,null],[10,"visit_map","petgraph::visit","",19,{"inputs":[{"name":"visitable"}],"output":{"name":"map"}}],[8,"GetAdjacencyMatrix","","Create or access the adjacency matrix of a graph",null,null],[16,"AdjMatrix","petgraph::visit::GetAdjacencyMatrix","",null,null],[10,"adjacency_matrix","petgraph::visit","",20,{"inputs":[{"name":"getadjacencymatrix"}],"output":{"name":"adjmatrix"}}],[10,"is_adjacent","","",20,{"inputs":[{"name":"getadjacencymatrix"},{"name":"adjmatrix"},{"name":"nodeid"},{"name":"nodeid"}],"output":{"name":"bool"}}],[6,"Iter","","",null,null],[11,"neighbors","petgraph::graph","",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[6,"Iter","petgraph::visit","",null,null],[11,"neighbors","petgraph::graphmap","",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"neighbors"}}],[6,"Iter","petgraph::visit","",null,null],[11,"neighbors","","",21,{"inputs":[{"name":"asundirected"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[6,"Iter","","",null,null],[11,"neighbors","","",22,{"inputs":[{"name":"reversed"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[11,"visit","fixedbitset","",23,{"inputs":[{"name":"fixedbitset"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"is_visited","","",23,{"inputs":[{"name":"fixedbitset"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"visit","std::collections::hash::set","",24,{"inputs":[{"name":"hashset"},{"name":"n"}],"output":{"name":"bool"}}],[11,"is_visited","","",24,{"inputs":[{"name":"hashset"},{"name":"n"}],"output":{"name":"bool"}}],[6,"NodeId","petgraph::visit","",null,null],[6,"Map","","",null,null],[11,"visit_map","petgraph::graph","",11,{"inputs":[{"name":"graph"}],"output":{"name":"fixedbitset"}}],[6,"NodeId","petgraph::visit","",null,null],[6,"Map","","",null,null],[11,"visit_map","petgraph::graphmap","",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"hashset"}}],[6,"NodeId","petgraph::visit","",null,null],[6,"NodeId","","",null,null],[6,"Map","","",null,null],[11,"visit_map","","",21,{"inputs":[{"name":"asundirected"}],"output":{"name":"v"}}],[6,"Map","","",null,null],[11,"visit_map","","",22,{"inputs":[{"name":"reversed"}],"output":{"name":"v"}}],[6,"AdjMatrix","","",null,null],[11,"adjacency_matrix","petgraph::graphmap","",3,{"inputs":[{"name":"graphmap"}],"output":null}],[11,"is_adjacent","","",3,null],[11,"fmt","petgraph::visit","",15,{"inputs":[{"name":"dfs"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"dfs"}],"output":{"name":"dfs"}}],[11,"new","","Create a new **Dfs**, using the graph's visitor map, and put **start**\nin the stack of nodes to visit.",15,{"inputs":[{"name":"dfs"},{"name":"g"},{"name":"g"}],"output":{"name":"self"}}],[11,"empty","","Create a new **Dfs** using the graph's visitor map, and no stack.",15,{"inputs":[{"name":"dfs"},{"name":"g"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe dfs from a particular node.",15,{"inputs":[{"name":"dfs"},{"name":"n"}],"output":null}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",15,{"inputs":[{"name":"dfs"},{"name":"g"}],"output":{"name":"option"}}],[11,"new","","",25,{"inputs":[{"name":"dfsiter"},{"name":"g"},{"name":"g"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe DFS traversal from a particular node.",25,{"inputs":[{"name":"dfsiter"},{"name":"g"}],"output":null}],[6,"Item","","",null,null],[11,"next","","",25,{"inputs":[{"name":"dfsiter"}],"output":{"name":"option"}}],[11,"size_hint","","",25,null],[11,"clone","","",25,{"inputs":[{"name":"dfsiter"}],"output":{"name":"self"}}],[11,"clone","","",16,{"inputs":[{"name":"bfs"}],"output":{"name":"bfs"}}],[11,"new","","Create a new **Bfs**, using the graph's visitor map, and put **start**\nin the stack of nodes to visit.",16,{"inputs":[{"name":"bfs"},{"name":"g"},{"name":"g"}],"output":{"name":"self"}}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",16,{"inputs":[{"name":"bfs"},{"name":"g"}],"output":{"name":"option"}}],[11,"new","","",26,{"inputs":[{"name":"bfsiter"},{"name":"g"},{"name":"g"}],"output":{"name":"self"}}],[6,"Item","","",null,null],[11,"next","","",26,{"inputs":[{"name":"bfsiter"}],"output":{"name":"option"}}],[11,"size_hint","","",26,null],[11,"clone","","",26,{"inputs":[{"name":"bfsiter"}],"output":{"name":"self"}}],[0,"unionfind","petgraph","**UnionFind\\<K\\>** is a disjoint-set data structure.",null,null],[3,"UnionFind","petgraph::unionfind","**UnionFind\\<K\\>** is a disjoint-set data structure. It tracks set membership of *n* elements\nindexed from *0* to *n - 1*. The scalar type is **K** which must be an unsigned integer type.",null,null],[11,"clone","","",27,{"inputs":[{"name":"unionfind"}],"output":{"name":"unionfind"}}],[11,"fmt","","",27,{"inputs":[{"name":"unionfind"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new **UnionFind** of **n** disjoint sets.",27,{"inputs":[{"name":"unionfind"},{"name":"usize"}],"output":{"name":"self"}}],[11,"find","","Return the representative for **x**.",27,{"inputs":[{"name":"unionfind"},{"name":"k"}],"output":{"name":"k"}}],[11,"find_mut","","Return the representative for **x**.",27,{"inputs":[{"name":"unionfind"},{"name":"k"}],"output":{"name":"k"}}],[11,"union","","Unify the two sets containing **x** and **y**.",27,{"inputs":[{"name":"unionfind"},{"name":"k"},{"name":"k"}],"output":{"name":"bool"}}],[11,"into_labeling","","Return a vector mapping each element to its representative.",27,{"inputs":[{"name":"unionfind"}],"output":{"name":"vec"}}],[11,"adjacency_matrix","petgraph::graph","",11,{"inputs":[{"name":"graph"}],"output":{"name":"fixedbitset"}}],[11,"is_adjacent","","",11,{"inputs":[{"name":"graph"},{"name":"fixedbitset"},{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[8,"EdgeType","petgraph","A graph's edge type determines whether is has directed edges or not.",null,null],[10,"is_directed","","",28,{"inputs":[{"name":"edgetype"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"edgedirection"},{"name":"edgedirection"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"edgedirection"},{"name":"edgedirection"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"edgedirection"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"edgedirection"}],"output":{"name":"edgedirection"}}],[11,"fmt","","",29,{"inputs":[{"name":"directed"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",29,{"inputs":[{"name":"directed"}],"output":{"name":"directed"}}],[11,"fmt","","",30,{"inputs":[{"name":"undirected"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",30,{"inputs":[{"name":"undirected"}],"output":{"name":"undirected"}}],[11,"is_directed","","",29,{"inputs":[{"name":"directed"}],"output":{"name":"bool"}}],[11,"is_directed","","",30,{"inputs":[{"name":"undirected"}],"output":{"name":"bool"}}],[11,"clone","","",31,{"inputs":[{"name":"ptr"}],"output":{"name":"self"}}],[11,"eq","","Ptr compares by pointer equality, i.e if they point to the same value",31,{"inputs":[{"name":"ptr"},{"name":"ptr"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",31,{"inputs":[{"name":"ptr"},{"name":"ptr"}],"output":{"name":"option"}}],[11,"cmp","","Ptr is ordered by pointer value, i.e. an arbitrary but stable and total order.",31,{"inputs":[{"name":"ptr"},{"name":"ptr"}],"output":{"name":"ordering"}}],[6,"Target","","",null,null],[11,"deref","","",31,{"inputs":[{"name":"ptr"}],"output":{"name":"t"}}],[11,"hash","","",31,{"inputs":[{"name":"ptr"},{"name":"h"}],"output":null}],[11,"fmt","","",31,{"inputs":[{"name":"ptr"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[4,"EdgeDirection"],[3,"MinScored"],[3,"Edges"],[3,"GraphMap"],[3,"Nodes"],[3,"Neighbors"],[3,"Node"],[3,"Edge"],[8,"IndexType"],[3,"NodeIndex"],[3,"EdgeIndex"],[3,"Graph"],[3,"WithoutEdges"],[3,"Neighbors"],[3,"Edges"],[3,"Dfs"],[3,"Bfs"],[8,"NeighborIter"],[8,"VisitMap"],[8,"Visitable"],[8,"GetAdjacencyMatrix"],[3,"AsUndirected"],[3,"Reversed"],[3,"FixedBitSet"],[3,"HashSet"],[3,"DfsIter"],[3,"BfsIter"],[3,"UnionFind"],[8,"EdgeType"],[3,"Directed"],[3,"Undirected"],[3,"Ptr"]]};
searchIndex['regex'] = {"items":[[0,"","regex","This crate provides a native implementation of regular expressions that is\nheavily based on RE2 both in syntax and in implementation. Notably,\nbackreferences and arbitrary lookahead/lookbehind assertions are not\nprovided. In return, regular expression searching provided by this package\nhas excellent worst case performance. The specific syntax supported is\ndocumented further down.",null,null],[3,"Captures","","Captures represents a group of captured strings for a single match.",null,null],[3,"SubCaptures","","An iterator over capture groups for a particular match of a regular\nexpression.",null,null],[3,"SubCapturesPos","","An iterator over capture group positions for a particular match of a\nregular expression.",null,null],[3,"SubCapturesNamed","","An Iterator over named capture groups as a tuple with the group\nname and the value.",null,null],[3,"FindCaptures","","An iterator that yields all non-overlapping capture groups matching a\nparticular regular expression.",null,null],[3,"FindMatches","","An iterator over all non-overlapping matches for a particular string.",null,null],[3,"NoExpand","","NoExpand indicates literal string replacement.",null,null],[3,"RegexSplits","","Yields all substrings delimited by a regular expression match.",null,null],[3,"RegexSplitsN","","Yields at most `N` substrings delimited by a regular expression match.",null,null],[4,"Regex","","A compiled regular expression",null,null],[4,"Error","","An error that occurred during parsing or compiling a regular expression.",null,null],[13,"Syntax","","A syntax error.",0,null],[13,"CompiledTooBig","","The compiled program exceeded the set size limit.\nThe argument is the size limit imposed.",0,null],[5,"quote","","Escapes all regular expression meta characters in `text`.",null,{"inputs":[{"name":"str"}],"output":{"name":"string"}}],[5,"is_match","","Tests if the given regular expression matches somewhere in the text given.",null,{"inputs":[{"name":"str"},{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",0,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[11,"cause","","",0,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[11,"fmt","","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",0,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"error"}}],[11,"clone","","",1,{"inputs":[{"name":"regex"}],"output":{"name":"regex"}}],[11,"fmt","","Shows the original regular expression.",1,{"inputs":[{"name":"regex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","Shows the original regular expression.",1,{"inputs":[{"name":"regex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"bool"}}],[11,"from_str","","Attempts to parse a string into a regular expression",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"result"}}],[11,"new","","Compiles a dynamic regular expression. Once compiled, it can be\nused repeatedly to search, split or replace text in a string.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"result"}}],[11,"with_size_limit","","Compiles a dynamic regular expression with the given size limit.",1,{"inputs":[{"name":"regex"},{"name":"usize"},{"name":"str"}],"output":{"name":"result"}}],[11,"is_match","","Returns true if and only if the regex matches the string given.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"bool"}}],[11,"find","","Returns the start and end byte range of the leftmost-first match in\n`text`. If no match exists, then `None` is returned.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"option"}}],[11,"find_iter","","Returns an iterator for each successive non-overlapping match in\n`text`, returning the start and end byte indices with respect to\n`text`.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"findmatches"}}],[11,"captures","","Returns the capture groups corresponding to the leftmost-first\nmatch in `text`. Capture group `0` always corresponds to the entire\nmatch. If no match is found, then `None` is returned.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"option"}}],[11,"captures_iter","","Returns an iterator over all the non-overlapping capture groups matched\nin `text`. This is operationally the same as `find_iter` (except it\nyields information about submatches).",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"findcaptures"}}],[11,"split","","Returns an iterator of substrings of `text` delimited by a match\nof the regular expression.\nNamely, each element of the iterator corresponds to text that *isn't*\nmatched by the regular expression.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"regexsplits"}}],[11,"splitn","","Returns an iterator of at most `limit` substrings of `text` delimited\nby a match of the regular expression. (A `limit` of `0` will return no\nsubstrings.)\nNamely, each element of the iterator corresponds to text that *isn't*\nmatched by the regular expression.\nThe remainder of the string that is not split will be the last element\nin the iterator.",1,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"usize"}],"output":{"name":"regexsplitsn"}}],[11,"replace","","Replaces the leftmost-first match with the replacement provided.\nThe replacement can be a regular string (where `$N` and `$name` are\nexpanded to match capture groups) or a function that takes the matches'\n`Captures` and returns the replaced string.",1,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"r"}],"output":{"name":"string"}}],[11,"replace_all","","Replaces all non-overlapping matches in `text` with the\nreplacement provided. This is the same as calling `replacen` with\n`limit` set to `0`.",1,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"r"}],"output":{"name":"string"}}],[11,"replacen","","Replaces at most `limit` non-overlapping matches in `text` with the\nreplacement provided. If `limit` is 0, then all non-overlapping matches\nare replaced.",1,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"usize"},{"name":"r"}],"output":{"name":"string"}}],[11,"as_str","","Returns the original string of this regex.",1,{"inputs":[{"name":"regex"}],"output":{"name":"str"}}],[11,"reg_replace","","",2,{"inputs":[{"name":"noexpand"},{"name":"captures"}],"output":{"name":"cow"}}],[11,"next","","",3,{"inputs":[{"name":"regexsplits"}],"output":{"name":"option"}}],[11,"next","","",4,{"inputs":[{"name":"regexsplitsn"}],"output":{"name":"option"}}],[11,"pos","","Returns the start and end positions of the Nth capture group.\nReturns `None` if `i` is not a valid capture group or if the capture\ngroup did not match anything.\nThe positions returned are *always* byte indices with respect to the\noriginal string matched.",5,{"inputs":[{"name":"captures"},{"name":"usize"}],"output":{"name":"option"}}],[11,"at","","Returns the matched string for the capture group `i`.  If `i` isn't\na valid capture group or didn't match anything, then `None` is\nreturned.",5,{"inputs":[{"name":"captures"},{"name":"usize"}],"output":{"name":"option"}}],[11,"name","","Returns the matched string for the capture group named `name`.  If\n`name` isn't a valid capture group or didn't match anything, then\n`None` is returned.",5,{"inputs":[{"name":"captures"},{"name":"str"}],"output":{"name":"option"}}],[11,"iter","","Creates an iterator of all the capture groups in order of appearance\nin the regular expression.",5,{"inputs":[{"name":"captures"}],"output":{"name":"subcaptures"}}],[11,"iter_pos","","Creates an iterator of all the capture group positions in order of\nappearance in the regular expression. Positions are byte indices\nin terms of the original string matched.",5,{"inputs":[{"name":"captures"}],"output":{"name":"subcapturespos"}}],[11,"iter_named","","Creates an iterator of all named groups as an tuple with the group\nname and the value. The iterator returns these values in arbitrary\norder.",5,{"inputs":[{"name":"captures"}],"output":{"name":"subcapturesnamed"}}],[11,"expand","","Expands all instances of `$name` in `text` to the corresponding capture\ngroup `name`.",5,{"inputs":[{"name":"captures"},{"name":"str"}],"output":{"name":"string"}}],[11,"len","","Returns the number of captured groups.",5,{"inputs":[{"name":"captures"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns true if and only if there are no captured groups.",5,{"inputs":[{"name":"captures"}],"output":{"name":"bool"}}],[11,"next","","",6,{"inputs":[{"name":"subcaptures"}],"output":{"name":"option"}}],[11,"next","","",7,{"inputs":[{"name":"subcapturespos"}],"output":{"name":"option"}}],[11,"next","","",8,{"inputs":[{"name":"subcapturesnamed"}],"output":{"name":"option"}}],[11,"next","","",9,{"inputs":[{"name":"findcaptures"}],"output":{"name":"option"}}],[11,"next","","",10,{"inputs":[{"name":"findmatches"}],"output":{"name":"option"}}],[8,"Replacer","","Replacer describes types that can be used to replace matches in a string.",null,null],[10,"reg_replace","","Returns a possibly owned string that is used to replace the match\ncorresponding to the `caps` capture group.",11,{"inputs":[{"name":"replacer"},{"name":"captures"}],"output":{"name":"cow"}}]],"paths":[[4,"Error"],[4,"Regex"],[3,"NoExpand"],[3,"RegexSplits"],[3,"RegexSplitsN"],[3,"Captures"],[3,"SubCaptures"],[3,"SubCapturesPos"],[3,"SubCapturesNamed"],[3,"FindCaptures"],[3,"FindMatches"],[8,"Replacer"]]};
searchIndex['regex_syntax'] = {"items":[[0,"","regex_syntax","This crate provides a regular expression parser and an abstract syntax for\nregular expressions. The abstract syntax is defined by the `Expr` type. The\nconcrete syntax is enumerated in the\n[`regex`](../regex/index.html#syntax)\ncrate documentation.",null,null],[3,"CharClass","","A character class.",null,null],[3,"ClassRange","","A single inclusive range in a character class.",null,null],[12,"start","","The start character of the range.",0,null],[12,"end","","The end character of the range.",0,null],[3,"Error","","A parse error.",null,null],[4,"Expr","","A regular expression abstract syntax tree.",null,null],[13,"Empty","","An empty regex (which never matches any text).",1,null],[13,"Literal","","A sequence of one or more literal characters to be matched.",1,null],[12,"chars","regex_syntax::Expr","The characters.",1,null],[12,"casei","","Whether to match case insensitively.",1,null],[13,"AnyChar","regex_syntax","Match any character, excluding new line.",1,null],[13,"AnyCharNoNL","","Match any character.",1,null],[13,"Class","","A character class.",1,null],[13,"StartLine","","Match the start of a line or beginning of input.",1,null],[13,"EndLine","","Match the end of a line or end of input.",1,null],[13,"StartText","","Match the beginning of input.",1,null],[13,"EndText","","Match the end of input.",1,null],[13,"WordBoundary","","Match a word boundary (word character on one side and a non-word\ncharacter on the other).",1,null],[13,"NotWordBoundary","","Match a position that is not a word boundary (word or non-word\ncharacters on both sides).",1,null],[13,"Group","","A group, possibly non-capturing.",1,null],[12,"e","regex_syntax::Expr","The expression inside the group.",1,null],[12,"i","","The capture index (starting at `1`) only for capturing groups.",1,null],[12,"name","","The capture name, only for capturing named groups.",1,null],[13,"Repeat","regex_syntax","A repeat operator (`?`, `*`, `+` or `{m,n}`).",1,null],[12,"e","regex_syntax::Expr","The expression to be repeated. Limited to literals, `.`, classes\nor grouped expressions.",1,null],[12,"r","","The type of repeat operator used.",1,null],[12,"greedy","","Whether the repeat is greedy (match the most) or not (match the\nleast).",1,null],[13,"Concat","regex_syntax","A concatenation of expressions. Must be matched one after the other.",1,null],[13,"Alternate","","An alternation of expressions. Only one must match.",1,null],[4,"Repeater","","The type of a repeat operator expression.",null,null],[13,"ZeroOrOne","","Match zero or one (`?`).",2,null],[13,"ZeroOrMore","","Match zero or more (`*`).",2,null],[13,"OneOrMore","","Match one or more (`+`).",2,null],[13,"Range","","Match for at least `min` and at most `max` (`{m,n}`).",2,null],[12,"min","regex_syntax::Repeater","Lower bound on the number of matches.",2,null],[12,"max","","Optional upper bound on the number of matches.",2,null],[4,"ErrorKind","regex_syntax","The specific type of parse error that can occur.",null,null],[13,"DoubleFlagNegation","","A negation symbol is used twice in flag settings.\ne.g., `(?-i-s)`.",3,null],[13,"DuplicateCaptureName","","The same capture name was used more than once.\ne.g., `(?P<a>.)(?P<a>.)`.",3,null],[13,"EmptyAlternate","","An alternate is empty. e.g., `(|a)`.",3,null],[13,"EmptyCaptureName","","A capture group name is empty. e.g., `(?P<>a)`.",3,null],[13,"EmptyFlagNegation","","A negation symbol was not proceded by any flags. e.g., `(?i-)`.",3,null],[13,"EmptyGroup","","A group is empty. e.g., `()`.",3,null],[13,"InvalidBase10","","An invalid number was used in a counted repetition. e.g., `a{b}`.",3,null],[13,"InvalidBase16","","An invalid hexadecimal number was used in an escape sequence.\ne.g., `\\xAG`.",3,null],[13,"InvalidCaptureName","","An invalid capture name was used. e.g., `(?P<0a>b)`.",3,null],[13,"InvalidClassRange","","An invalid class range was givien. Specifically, when the start of the\nrange is greater than the end. e.g., `[z-a]`.",3,null],[12,"start","regex_syntax::ErrorKind","The first character specified in the range.",3,null],[12,"end","","The second character specified in the range.",3,null],[13,"InvalidClassEscape","regex_syntax","An escape sequence was used in a character class where it is not\nallowed. e.g., `[a-\\pN]` or `[\\A]`.",3,null],[13,"InvalidRepeatRange","","An invalid counted repetition min/max was given. e.g., `a{2,1}`.",3,null],[12,"min","regex_syntax::ErrorKind","The first number specified in the repetition.",3,null],[12,"max","","The second number specified in the repetition.",3,null],[13,"InvalidScalarValue","regex_syntax","An invalid Unicode scalar value was used in a long hexadecimal\nsequence. e.g., `\\x{D800}`.",3,null],[13,"MissingBase10","","An empty counted repetition operator. e.g., `a{}`.",3,null],[13,"RepeaterExpectsExpr","","A repetition operator was not applied to an expression. e.g., `*`.",3,null],[13,"RepeaterUnexpectedExpr","","A repetition operator was applied to an expression that cannot be\nrepeated. e.g., `a+*` or `a|*`.",3,null],[13,"UnclosedCaptureName","","A capture group name that is never closed. e.g., `(?P<a`.",3,null],[13,"UnclosedHex","","An unclosed hexadecimal literal. e.g., `\\x{a`.",3,null],[13,"UnclosedParen","","An unclosed parenthesis. e.g., `(a`.",3,null],[13,"UnclosedRepeat","","An unclosed counted repetition operator. e.g., `a{2`.",3,null],[13,"UnclosedUnicodeName","","An unclosed named Unicode class. e.g., `\\p{Yi`.",3,null],[13,"UnexpectedClassEof","","Saw end of regex before class was closed. e.g., `[a`.",3,null],[13,"UnexpectedEscapeEof","","Saw end of regex before escape sequence was closed. e.g., `\\`.",3,null],[13,"UnexpectedFlagEof","","Saw end of regex before flags were closed. e.g., `(?i`.",3,null],[13,"UnexpectedTwoDigitHexEof","","Saw end of regex before two hexadecimal digits were seen. e.g., `\\xA`.",3,null],[13,"UnopenedParen","","Unopened parenthesis. e.g., `)`.",3,null],[13,"UnrecognizedEscape","","Unrecognized escape sequence. e.g., `\\q`.",3,null],[13,"UnrecognizedFlag","","Unrecognized flag. e.g., `(?a)`.",3,null],[13,"UnrecognizedUnicodeClass","","Unrecognized named Unicode class. e.g., `\\p{Foo}`.",3,null],[5,"quote","","Escapes all regular expression meta characters in `text`.",null,{"inputs":[{"name":"str"}],"output":{"name":"string"}}],[6,"Result","","An alias for computations that can return a `Error`.",null,null],[11,"eq","","",1,{"inputs":[{"name":"expr"},{"name":"expr"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"expr"},{"name":"expr"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"expr"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"expr"}],"output":{"name":"expr"}}],[11,"eq","","",2,{"inputs":[{"name":"repeater"},{"name":"repeater"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"repeater"},{"name":"repeater"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"repeater"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"repeater"}],"output":{"name":"repeater"}}],[11,"eq","","",4,{"inputs":[{"name":"charclass"},{"name":"charclass"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"charclass"},{"name":"charclass"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"charclass"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"charclass"}],"output":{"name":"charclass"}}],[11,"cmp","","",0,{"inputs":[{"name":"classrange"},{"name":"classrange"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"classrange"},{"name":"classrange"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"classrange"},{"name":"classrange"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"classrange"},{"name":"classrange"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"classrange"},{"name":"classrange"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"classrange"},{"name":"classrange"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"classrange"},{"name":"classrange"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"classrange"},{"name":"classrange"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"classrange"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"classrange"}],"output":{"name":"classrange"}}],[11,"parse","","Parses a string in a regular expression syntax tree.",1,{"inputs":[{"name":"expr"},{"name":"str"}],"output":{"name":"result"}}],[6,"Target","","",null,null],[11,"deref","","",4,{"inputs":[{"name":"charclass"}],"output":{"name":"vec"}}],[6,"Item","","",null,null],[6,"IntoIter","","",null,null],[11,"into_iter","","",4,{"inputs":[{"name":"charclass"}],"output":{"name":"intoiter"}}],[6,"Item","","",null,null],[6,"IntoIter","","",null,null],[11,"matches","","Returns true if `c` is matched by this character class.",4,{"inputs":[{"name":"charclass"},{"name":"char"}],"output":{"name":"bool"}}],[11,"is_case_insensitive","","Returns true if this character class should be matched case\ninsensitively.",4,{"inputs":[{"name":"charclass"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"classrange"},{"name":"char"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"classrange"},{"name":"char"}],"output":{"name":"option"}}],[11,"fmt","","",1,{"inputs":[{"name":"expr"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"repeater"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"charclass"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"classrange"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"fmt","","",5,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"eq","","",3,{"inputs":[{"name":"errorkind"},{"name":"errorkind"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"errorkind"},{"name":"errorkind"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"errorkind"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"errorkind"}],"output":{"name":"errorkind"}}],[11,"position","","Returns an approximate *character* offset at which the error occurred.",5,{"inputs":[{"name":"error"}],"output":{"name":"usize"}}],[11,"kind","","Returns the type of the regex parse error.",5,{"inputs":[{"name":"error"}],"output":{"name":"errorkind"}}],[11,"description","","",5,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[11,"fmt","","",5,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"errorkind"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[3,"ClassRange"],[4,"Expr"],[4,"Repeater"],[4,"ErrorKind"],[3,"CharClass"],[3,"Error"]]};
searchIndex['fixedbitset'] = {"items":[[0,"","fixedbitset","**FixedBitSet** is a simple fixed size set of bits.",null,null],[3,"FixedBitSet","","**FixedBitSet** is a simple fixed size set of bits that can\nbe enabled (1 / **true**) or disabled (0 / **false**).",null,null],[11,"hash","","",0,null],[11,"cmp","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"with_capacity","","Create a new **FixedBitSet** with a specific number of bits,\nall initially clear.",0,{"inputs":[{"name":"fixedbitset"},{"name":"usize"}],"output":{"name":"self"}}],[11,"len","","Return the length of the **FixedBitSet** in bits.",0,{"inputs":[{"name":"fixedbitset"}],"output":{"name":"usize"}}],[11,"contains","","Return **true** if the bit is enabled in the **FixedBitSet**,\n**false** otherwise.",0,{"inputs":[{"name":"fixedbitset"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"clear","","Clear all bits.",0,{"inputs":[{"name":"fixedbitset"}],"output":null}],[11,"insert","","**Panics** if **bit** is out of bounds.",0,{"inputs":[{"name":"fixedbitset"},{"name":"usize"}],"output":null}],[11,"set","","**Panics** if **bit** is out of bounds.",0,{"inputs":[{"name":"fixedbitset"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"as_slice","","View the bitset as a slice of `u32` blocks",0,null],[11,"as_mut_slice","","View the bitset as a mutable slice of `u32` blocks. Writing past the bitlength in the last\nwill cause `contains` to return potentially incorrect results for bits past the bitlength.",0,null],[11,"clone","","",0,{"inputs":[{"name":"fixedbitset"}],"output":{"name":"self"}}],[6,"Output","","",null,null],[11,"index","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"usize"}],"output":{"name":"bool"}}]],"paths":[[3,"FixedBitSet"]]};
searchIndex['rustc_data_structures'] = {"items":[[0,"","rustc_data_structures","Various data structures used by the Rust compiler. The intention\nis that code in here should be not be *specific* to rustc, so that\nit can be easily unit tested and so forth.",null,null],[0,"snapshot_vec","","A utility class for implementing \"snapshottable\" things; a snapshottable data structure permits\nyou to take a snapshot (via `start_snapshot`) and then, after making some changes, elect either\nto rollback to the start of the snapshot or commit those changes.",null,null],[3,"SnapshotVec","rustc_data_structures::snapshot_vec","",null,null],[3,"Snapshot","","",null,null],[4,"UndoLog","","",null,null],[13,"OpenSnapshot","","Indicates where a snapshot started.",0,null],[13,"CommittedSnapshot","","Indicates a snapshot that has been committed.",0,null],[13,"NewElem","","New variable with given index was created.",0,null],[13,"SetElem","","Variable with given index was changed *from* the given value.",0,null],[13,"Other","","Extensible set of actions",0,null],[8,"SnapshotVecDelegate","","",null,null],[16,"Value","rustc_data_structures::snapshot_vec::SnapshotVecDelegate","",null,null],[16,"Undo","","",null,null],[10,"reverse","rustc_data_structures::snapshot_vec","",1,{"inputs":[{"name":"snapshotvecdelegate"},{"name":"vec"},{"name":"undo"}],"output":null}],[11,"new","","",2,{"inputs":[{"name":"snapshotvec"}],"output":{"name":"snapshotvec"}}],[11,"record","","",2,{"inputs":[{"name":"snapshotvec"},{"name":"d"}],"output":null}],[11,"len","","",2,{"inputs":[{"name":"snapshotvec"}],"output":{"name":"usize"}}],[11,"push","","",2,{"inputs":[{"name":"snapshotvec"},{"name":"d"}],"output":{"name":"usize"}}],[11,"get","","",2,{"inputs":[{"name":"snapshotvec"},{"name":"usize"}],"output":{"name":"d"}}],[11,"get_mut","","Returns a mutable pointer into the vec; whatever changes you make here cannot be undone\nautomatically, so you should be sure call `record()` with some sort of suitable undo\naction.",2,{"inputs":[{"name":"snapshotvec"},{"name":"usize"}],"output":{"name":"d"}}],[11,"set","","Updates the element at the given index. The old value will saved (and perhaps restored) if\na snapshot is active.",2,{"inputs":[{"name":"snapshotvec"},{"name":"usize"},{"name":"d"}],"output":null}],[11,"start_snapshot","","",2,{"inputs":[{"name":"snapshotvec"}],"output":{"name":"snapshot"}}],[11,"actions_since_snapshot","","",2,null],[11,"rollback_to","","",2,{"inputs":[{"name":"snapshotvec"},{"name":"snapshot"}],"output":null}],[11,"commit","","Commits all changes since the last snapshot. Of course, they\ncan still be undone if there is a snapshot further out.",2,{"inputs":[{"name":"snapshotvec"},{"name":"snapshot"}],"output":null}],[6,"Target","","",null,null],[11,"deref","","",2,null],[11,"deref_mut","","",2,null],[6,"Output","","",null,null],[11,"index","","",2,{"inputs":[{"name":"snapshotvec"},{"name":"usize"}],"output":{"name":"d"}}],[11,"index_mut","","",2,{"inputs":[{"name":"snapshotvec"},{"name":"usize"}],"output":{"name":"d"}}],[0,"graph","rustc_data_structures","A graph module for use in dataflow, region resolution, and elsewhere.",null,null],[3,"Graph","rustc_data_structures::graph","",null,null],[3,"Node","","",null,null],[12,"data","","",3,null],[3,"Edge","","",null,null],[12,"data","","",4,null],[3,"NodeIndex","","",null,null],[3,"EdgeIndex","","",null,null],[3,"Direction","","",null,null],[3,"AdjacentEdges","","",null,null],[3,"AdjacentTargets","","",null,null],[3,"AdjacentSources","","",null,null],[3,"DepthFirstTraversal","","",null,null],[5,"each_edge_index","","",null,{"inputs":[{"name":"edgeindex"},{"name":"f"}],"output":null}],[17,"INVALID_EDGE_INDEX","","",null,null],[17,"OUTGOING","","",null,null],[17,"INCOMING","","",null,null],[6,"Value","","",null,null],[6,"Undo","","",null,null],[11,"reverse","","",3,null],[6,"Value","","",null,null],[6,"Undo","","",null,null],[11,"reverse","","",4,null],[11,"fmt","","",4,{"inputs":[{"name":"edge"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"nodeindex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"clone","","",5,{"inputs":[{"name":"nodeindex"}],"output":{"name":"nodeindex"}}],[11,"fmt","","",6,{"inputs":[{"name":"edgeindex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"clone","","",6,{"inputs":[{"name":"edgeindex"}],"output":{"name":"edgeindex"}}],[11,"fmt","","",7,{"inputs":[{"name":"direction"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"direction"}],"output":{"name":"direction"}}],[11,"node_id","","Returns unique id (unique with respect to the graph holding associated node).",5,{"inputs":[{"name":"nodeindex"}],"output":{"name":"usize"}}],[11,"edge_id","","Returns unique id (unique with respect to the graph holding associated edge).",6,{"inputs":[{"name":"edgeindex"}],"output":{"name":"usize"}}],[11,"new","","",8,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[11,"all_nodes","","",8,null],[11,"all_edges","","",8,null],[11,"next_node_index","","",8,{"inputs":[{"name":"graph"}],"output":{"name":"nodeindex"}}],[11,"add_node","","",8,{"inputs":[{"name":"graph"},{"name":"n"}],"output":{"name":"nodeindex"}}],[11,"mut_node_data","","",8,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"n"}}],[11,"node_data","","",8,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"n"}}],[11,"node","","",8,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"node"}}],[11,"next_edge_index","","",8,{"inputs":[{"name":"graph"}],"output":{"name":"edgeindex"}}],[11,"add_edge","","",8,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"},{"name":"e"}],"output":{"name":"edgeindex"}}],[11,"mut_edge_data","","",8,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"e"}}],[11,"edge_data","","",8,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"e"}}],[11,"edge","","",8,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"edge"}}],[11,"first_adjacent","","Accesses the index of the first edge adjacent to `node`.\nThis is useful if you wish to modify the graph while walking\nthe linked list of edges.",8,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"direction"}],"output":{"name":"edgeindex"}}],[11,"next_adjacent","","Accesses the next edge in a given direction.\nThis is useful if you wish to modify the graph while walking\nthe linked list of edges.",8,{"inputs":[{"name":"graph"},{"name":"edgeindex"},{"name":"direction"}],"output":{"name":"edgeindex"}}],[11,"each_node","","Iterates over all edges defined in the graph.",8,{"inputs":[{"name":"graph"},{"name":"f"}],"output":{"name":"bool"}}],[11,"each_edge","","Iterates over all edges defined in the graph",8,{"inputs":[{"name":"graph"},{"name":"f"}],"output":{"name":"bool"}}],[11,"outgoing_edges","","",8,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"adjacentedges"}}],[11,"incoming_edges","","",8,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"adjacentedges"}}],[11,"adjacent_edges","","",8,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"direction"}],"output":{"name":"adjacentedges"}}],[11,"successor_nodes","","",8,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"adjacenttargets"}}],[11,"predecessor_nodes","","",8,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"adjacentsources"}}],[11,"iterate_until_fixed_point","","",8,{"inputs":[{"name":"graph"},{"name":"f"}],"output":null}],[11,"depth_traverse","","",8,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"depthfirsttraversal"}}],[6,"Item","","",null,null],[11,"next","","",9,{"inputs":[{"name":"adjacentedges"}],"output":{"name":"option"}}],[6,"Item","","",null,null],[11,"next","","",10,{"inputs":[{"name":"adjacenttargets"}],"output":{"name":"option"}}],[6,"Item","","",null,null],[11,"next","","",11,{"inputs":[{"name":"adjacentsources"}],"output":{"name":"option"}}],[6,"Item","","",null,null],[11,"next","","",12,{"inputs":[{"name":"depthfirsttraversal"}],"output":{"name":"option"}}],[11,"source","","",4,{"inputs":[{"name":"edge"}],"output":{"name":"nodeindex"}}],[11,"target","","",4,{"inputs":[{"name":"edge"}],"output":{"name":"nodeindex"}}],[0,"bitvec","rustc_data_structures","",null,null],[3,"BitVector","rustc_data_structures::bitvec","A very simple BitVector type.",null,null],[11,"new","","",13,{"inputs":[{"name":"bitvector"},{"name":"usize"}],"output":{"name":"bitvector"}}],[11,"contains","","",13,{"inputs":[{"name":"bitvector"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"insert","","",13,{"inputs":[{"name":"bitvector"},{"name":"usize"}],"output":{"name":"bool"}}],[0,"unify","rustc_data_structures","",null,null],[3,"VarValue","rustc_data_structures::unify","Value of a unification key. We implement Tarjan's union-find\nalgorithm: when two keys are unified, one of them is converted\ninto a \"redirect\" pointing at the other. These redirects form a\nDAG: the roots of the DAG (nodes that are not redirected) are each\nassociated with a value of type `V` and a rank. The rank is used\nto keep the DAG relatively balanced, which helps keep the running\ntime of the algorithm under control. For more information, see\n<http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.",null,null],[3,"UnificationTable","","Table of unification keys and their values.",null,null],[3,"Snapshot","","At any time, users may snapshot a unification table.  The changes\nmade during the snapshot may either be *committed* or *rolled back*.",null,null],[8,"UnifyKey","","This trait is implemented by any type that can serve as a type\nvariable. We call such variables *unification keys*. For example,\nthis trait is implemented by `IntVid`, which represents integral\nvariables.",null,null],[16,"Value","rustc_data_structures::unify::UnifyKey","",null,null],[10,"index","rustc_data_structures::unify","",14,{"inputs":[{"name":"unifykey"}],"output":{"name":"u32"}}],[10,"from_index","","",14,{"inputs":[{"name":"unifykey"},{"name":"u32"}],"output":{"name":"self"}}],[10,"tag","","",14,{"inputs":[{"name":"unifykey"},{"name":"option"}],"output":{"name":"str"}}],[11,"fmt","","",15,{"inputs":[{"name":"varvalue"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"varvalue"}],"output":{"name":"varvalue"}}],[11,"eq","","",15,{"inputs":[{"name":"varvalue"},{"name":"varvalue"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"varvalue"},{"name":"varvalue"}],"output":{"name":"bool"}}],[11,"new","","",16,{"inputs":[{"name":"unificationtable"}],"output":{"name":"unificationtable"}}],[11,"snapshot","","Starts a new snapshot. Each snapshot must be either\nrolled back or committed in a \"LIFO\" (stack) order.",16,{"inputs":[{"name":"unificationtable"}],"output":{"name":"snapshot"}}],[11,"rollback_to","","Reverses all changes since the last snapshot. Also\nremoves any keys that have been created since then.",16,{"inputs":[{"name":"unificationtable"},{"name":"snapshot"}],"output":null}],[11,"commit","","Commits all changes since the last snapshot. Of course, they\ncan still be undone if there is a snapshot further out.",16,{"inputs":[{"name":"unificationtable"},{"name":"snapshot"}],"output":null}],[11,"new_key","","",16,{"inputs":[{"name":"unificationtable"},{"name":"k"}],"output":{"name":"k"}}],[11,"union","","",16,{"inputs":[{"name":"unificationtable"},{"name":"k"},{"name":"k"}],"output":null}],[11,"find","","",16,{"inputs":[{"name":"unificationtable"},{"name":"k"}],"output":{"name":"k"}}],[11,"unioned","","",16,{"inputs":[{"name":"unificationtable"},{"name":"k"},{"name":"k"}],"output":{"name":"bool"}}],[11,"unify_var_var","","",16,{"inputs":[{"name":"unificationtable"},{"name":"k"},{"name":"k"}],"output":{"name":"result"}}],[11,"unify_var_value","","Sets the value of the key `a_id` to `b`. Because simple keys do not have any subtyping\nrelationships, if `a_id` already has a value, it must be the same as `b`.",16,{"inputs":[{"name":"unificationtable"},{"name":"k"},{"name":"v"}],"output":{"name":"result"}}],[11,"has_value","","",16,{"inputs":[{"name":"unificationtable"},{"name":"k"}],"output":{"name":"bool"}}],[11,"probe","","",16,{"inputs":[{"name":"unificationtable"},{"name":"k"}],"output":{"name":"option"}}]],"paths":[[4,"UndoLog"],[8,"SnapshotVecDelegate"],[3,"SnapshotVec"],[3,"Node"],[3,"Edge"],[3,"NodeIndex"],[3,"EdgeIndex"],[3,"Direction"],[3,"Graph"],[3,"AdjacentEdges"],[3,"AdjacentTargets"],[3,"AdjacentSources"],[3,"DepthFirstTraversal"],[3,"BitVector"],[8,"UnifyKey"],[3,"VarValue"],[3,"UnificationTable"]]};
initSearch(searchIndex);
